<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>הלימוד היומי</title>
  
  <!-- קישור למניפסט של PWA -->
  <link rel="manifest" href="manifest.json">
  
  <style>
    body {
      font-family: "Alef", sans-serif;
      background: url('https://your-background-image-url.com') no-repeat center center fixed;
      background-size: cover;
      color: #333;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #fff;
      text-shadow: 2px 2px 4px #000;
    }
    .box {
      margin: 20px auto;
      max-width: 800px;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }
    h2 {
      margin-top: 0;
      color: #2c3e50;
    }
    #toggleAddBookBtn {
      display: block;
      width: 100%;
      margin: 20px auto;
      padding: 15px;
      border: none;
      border-radius: 5px;
      background: #2ecc71;
      color: #fff;
      font-size: 1.1rem;
      cursor: pointer;
      text-align: center;
      transition: background 0.3s;
    }
    #toggleAddBookBtn:hover {
      background: #27ae60;
    }
    #addBookContainer {
      display: none;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
      color: #34495e;
    }
    input, select, button {
      width: 100%;
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 1rem;
      box-sizing: border-box;
    }
    button {
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    .bookContainer {
      margin-bottom: 20px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 10px;
    }
    .bookTitle {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 1.2rem;
      cursor: pointer;
      color: #2980b9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .bookTitle:hover {
      text-decoration: underline;
    }
    .chunkText {
      margin: 10px 0;
      font-size: 1rem;
      line-height: 1.6;
      white-space: pre-line;
      display: none; /* מוסתר כברירת מחדל */
      background: #ecf0f1;
      padding: 10px;
      border-radius: 5px;
      position: relative;
    }
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: space-between;
      margin-top: 10px;
    }
    .navigationBtn,
    .markReadBtn,
    .removeBtn {
      padding: 8px 16px;
      font-size: 0.9rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #fff;
      transition: background 0.3s;
      flex: 1;
      margin: 5px;
    }
    .navigationBtn {
      background: #3498db;
    }
    .navigationBtn:hover {
      background: #2980b9;
    }
    .markReadBtn {
      background: #8e44ad;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .markReadBtn:hover {
      background: #71368a;
    }
    .removeBtn {
      background: #e74c3c;
      flex: 2;
    }
    .removeBtn:hover {
      background: #c0392b;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-size: 1.5rem;
      color: #3498db;
    }
    @media (max-width: 600px) {
      .box {
        max-width: 90%;
      }
      #toggleAddBookBtn {
        max-width: 90%;
      }
      .btnRow {
        flex-direction: column;
      }
    }
    /* סגנון לרובריקת סימון כנלמד */
    .markReadContainer {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    .markReadCheckbox {
      width: 20px;
      height: 20px;
      border: 2px solid #2980b9;
      border-radius: 3px;
      cursor: pointer;
      position: relative;
    }
    .markReadCheckbox.checked::after {
      content: '✔';
      position: absolute;
      top: -4px;
      left: 2px;
      font-size: 18px;
      color: #2980b9;
    }
    .markReadLabel {
      cursor: pointer;
      color: #2980b9;
      user-select: none;
    }
    /* קו מפריד בין קטעי לימוד */
    .separator {
      border-bottom: 1px solid #bdc3c7;
      margin: 10px 0;
    }
  </style>
</head>
<body dir="rtl">
  <h1>הלימוד היומי</h1>

  <!-- כפתור לפתיחת הטופס להוספת לימוד -->
  <button id="toggleAddBookBtn" onclick="toggleAddBookForm()">
    הוספת לימוד יומי מתוך ספר
  </button>

  <!-- תיבה מוסתרת עם טופס הוספת לימוד -->
  <div id="addBookContainer" class="box">
    <h2>טופס הוספת לימוד יומי</h2>
    <label for="bookName">שם הספר (למשל: מסילת ישרים):</label>
    <input type="text" id="bookName" placeholder="מסילת ישרים" required />

    <label for="studyType">סוג הלימוד:</label>
    <select id="studyType">
      <option value="word">מספר מילים יומית</option>
      <option value="chapter">מספר פרקים יומית</option>
    </select>

    <div id="wordCountContainer">
      <label for="wordCount">כמות מילים יומית (לדוגמה: 300):</label>
      <input type="number" id="wordCount" placeholder="300" min="50" max="1000" required />
    </div>

    <div id="chapterCountContainer" style="display: none;">
      <label for="chapterCount">מספר פרקים יומית (לדוגמה: 1):</label>
      <input type="number" id="chapterCount" placeholder="1" min="1" required />
    </div>

    <label for="mode">מצב לימוד:</label>
    <select id="mode">
      <option value="accumulate">חובות מצטברים</option>
      <option value="no_accumulate">ללא חובות מצטברים</option>
    </select>

    <button onclick="addBook()">הוסף לימוד</button>
  </div>

  <!-- תיבה להצגת הלימודים הפעילים -->
  <div id="content" class="box">
    <h2>לימודים פעילים</h2>
    <div id="booksContainer">
      <p>לא הוספת לימודים עדיין.</p>
    </div>
  </div>

  <!-- אינדיקטור טעינה -->
  <div id="loadingIndicator" class="loading-overlay" style="display: none;">
    טוען...
  </div>

  <!-- Service Worker Registration for PWA -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('service-worker.js').then(function(registration) {
          console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, function(err) {
          console.log('ServiceWorker registration failed: ', err);
        });
      });
    }
  </script>

  <script>
    /*
      מבנה הנתונים במערך books:
      books = [
        {
          id: מזהה ייחודי (Date.now()),
          name: "מסילת ישרים",
          mode: "accumulate" | "no_accumulate",
          studyType: "word" | "chapter",
          wordCount: 300, // אם studyType = "word"
          chapterCount: 1, // אם studyType = "chapter"
          chapters: [ // רשימת פרקים שנטענו
            {
              chapterNumber: 1,
              text: "טקסט הפרק",
              chunks: [ { text: "...", read: false }, ... ],
            },
            ...
          ],
          currentChapterIndex: 0,
          currentChunkIndex: 0,
          latestChapterIndex: 0, // במצב 'no_accumulate', זה מתעדכן רק לאחר סימון קריאה
          readChapters: [], // רשימת פרקים שסומנו כנקראים (במצב 'no_accumulate')
          lastAccessDate: "" // לניהול יום חדש
        }
      ]
    */

    let books = JSON.parse(localStorage.getItem("books")) || [];

    // פונקציה עם ריטריי וטיימאאוט לבקשות API
    async function fetchWithRetry(url, maxRetries = 3, timeout = 5000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    // מטמון לעיבוד הטקסט
    const textProcessingCache = new Map();

    function processText(text, wordCount) {
      const cacheKey = `${text.slice(0, 100)}_${wordCount}`;
      if (textProcessingCache.has(cacheKey)) {
        return textProcessingCache.get(cacheKey);
      }

      const chunks = splitIntoChunks(text, wordCount);
      textProcessingCache.set(cacheKey, chunks);
      
      // ניקוי המטמון אם גדול מדי
      if (textProcessingCache.size > 100) {
        const firstKey = textProcessingCache.keys().next().value;
        textProcessingCache.delete(firstKey);
      }
      
      return chunks;
    }

    // חלוקת טקסט לקטעים לפי מספר מילים או פרקים
    function splitIntoChunks(text, count, type = 'word') {
      const paragraphs = text.split(/\n{2,}/).filter(p => p.trim() !== '');
      const chunks = [];
      let currentChunk = "";
      let currentCount = 0;

      for (let para of paragraphs) {
        const pWords = para.split(/\s+/).filter(Boolean).length;
        if (type === 'word') {
          if (currentCount + pWords <= count) {
            currentChunk += (currentChunk ? "\n\n" : "") + para;
            currentCount += pWords;
          } else {
            if (currentChunk) {
              chunks.push({ text: currentChunk, read: false });
            }
            currentChunk = para;
            currentCount = pWords;
          }
        } else if (type === 'chapter') {
          // במקרה של לימוד לפי פרקים, כל פרק הוא קטע
          chunks.push({ text: para, read: false });
          currentChunk = "";
          currentCount = 0;
        }
      }

      if (currentChunk) {
        chunks.push({ text: currentChunk, read: false });
      }

      return chunks;
    }

    // ולידציה משופרת
    function validateBookInput(bookName, wordCount, chapterCount) {
      const errors = [];
      
      if (!bookName || bookName.length < 2) {
        errors.push("שם הספר חייב להכיל לפחות 2 תווים.");
      }
      
      if (wordCount !== undefined && (wordCount < 50 || wordCount > 1000)) {
        errors.push("מספר המילים חייב להיות בין 50 ל-1000.");
      }
      
      if (chapterCount !== undefined && (chapterCount < 1)) {
        errors.push("מספר הפרקים היומית חייב להיות לפחות 1.");
      }
      
      if (/[<>%$]/.test(bookName)) {
        errors.push("שם הספר מכיל תווים לא חוקיים (כמו <, >, %, $).");
      }
      
      return errors;
    }

    // דבונסינג לרינדור
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    const debouncedRenderBooks = debounce(renderBooks, 250);

    // מציג/מסתיר את טופס הוספת לימוד
    function toggleAddBookForm() {
      const container = document.getElementById("addBookContainer");
      if (container.style.display === "none" || container.style.display === "") {
        container.style.display = "block";
      } else {
        container.style.display = "none";
      }
    }

    // פונקציה להראות/להסתיר אינדיקטור טעינה
    function showLoadingIndicator(show) {
      const loadingDiv = document.getElementById('loadingIndicator');
      loadingDiv.style.display = show ? 'flex' : 'none';
    }

    // הגדרת תחיליות לפרקים
    const chapterPrefixes = ['פרק', 'סימן', 'שער', 'סעיף', 'פרשה', 'נתיב', 'על זו הדרך'];

    // הוספת לימוד חדש
    async function addBook() {
      const bookNameInput = document.getElementById("bookName").value.trim();
      const studyType = document.getElementById("studyType").value;
      const wordCount = parseInt(document.getElementById("wordCount").value);
      const chapterCount = parseInt(document.getElementById("chapterCount").value);
      const mode = document.getElementById("mode").value;

      // ולידציה
      let validationErrors;
      if (studyType === 'word') {
        validationErrors = validateBookInput(bookNameInput, wordCount);
      } else {
        validationErrors = validateBookInput(bookNameInput, undefined, chapterCount);
      }

      if (validationErrors.length > 0) {
        alert(validationErrors.join("\n"));
        return;
      }

      // המרת שם הספר לפורמט שמתאים ל-API של ספריא (החלפת רווחים בקווים תחתונים)
      const apiBookName = bookNameInput.replace(/\s+/g, '_');

      try {
        showLoadingIndicator(true);

        // השתמש ב-fetchWithRetry
        const apiUrl = `https://www.sefaria.org/api/texts/${encodeURIComponent(apiBookName)}?lang=he`;
        const data = await fetchWithRetry(apiUrl);

        // חילוץ הטקסט מהתשובה
        const textArray = data.he;

        if (!textArray || textArray.length === 0) {
          throw new Error("לא אותרו פסקאות או שהטקסט ריק.");
        }

        // הגדרת סעיפים לא רצויים להימנעות מהם
        const unwantedSections = ["הקדמה", "אינדקס", "הערות", "סיכומים", "תודות", "ספרות", "עריכה", "פרקים"];

        // סינון הפסקאות כדי להתחיל מדברי המחבר בלבד
        const processedParagraphs = [];
        let skip = true;
        let currentChapter = determineChapterPrefix(bookNameInput, 1); // התחלת הפרק הראשון

        for (let para of textArray) {
          // בדיקה אם הפסקה מתחילה באחד הסעיפים הלא רצויים
          if (unwantedSections.some(section => para.startsWith(section))) {
            skip = true;
            continue;
          }

          // בדיקה אם הפסקה מתחילה בפרק
          const chapterMatch = para.match(new RegExp(`^(${chapterPrefixes.join('|')})\\s*\\w+`));
          if (chapterMatch) {
            currentChapter = para.trim();
            skip = false;
            continue; // לא כולל את כותרת הפרק כפרק
          }

          // בדיקה אם הפסקה אינה חלק מהסעיפים הלא רצויים
          if (skip && !unwantedSections.some(section => para.startsWith(section))) {
            skip = false;
          }

          if (!skip) {
            processedParagraphs.push({ text: para, chapter: currentChapter });
          }
        }

        if (processedParagraphs.length === 0) {
          throw new Error("לא אותרו פסקאות או שהטקסט ריק לאחר הסינון.");
        }

        // חלוקה לפרקים
        const chaptersMap = {}; // מיפוי פרקים לטקסט שלהם
        processedParagraphs.forEach(para => {
          if (!chaptersMap[para.chapter]) {
            chaptersMap[para.chapter] = [];
          }
          chaptersMap[para.chapter].push(para.text);
        });

        // יצירת רשימת פרקים
        const chaptersList = Object.keys(chaptersMap).map((chapterName, index) => ({
          chapterNumber: index + 1,
          text: chaptersMap[chapterName].join('\n\n'),
          chunks: studyType === 'word' ? splitIntoChunks(chaptersMap[chapterName].join('\n\n'), wordCount, 'word') : splitIntoChunks(chaptersMap[chapterName].join('\n\n'), chapterCount, 'chapter')
        }));

        if (chaptersList.length === 0) {
          throw new Error("לא נמצאו פרקים לטעינה.");
        }

        // יצירת אובייקט הספר
        const newBook = {
          id: Date.now(),
          name: apiBookName.replace(/_/g, ' '), // שמירה על השם המקורי עם רווחים
          mode: mode,
          studyType: studyType,
          wordCount: studyType === 'word' ? wordCount : undefined,
          chapterCount: studyType === 'chapter' ? chapterCount : undefined,
          chapters: chaptersList.slice(0, studyType === 'word' ? 1 : chapterCount), // טען בהתאם לסוג הלימוד
          currentChapterIndex: 0,
          currentChunkIndex: 0,
          latestChapterIndex: mode === "accumulate" ? chaptersList.length - 1 : 0, // במצב accumulate, נעדכן בטעינת הפרקים
          readChapters: [], // במצב 'no_accumulate', רשימת פרקים שסומנו כנקראים
          lastAccessDate: ""
        };

        books.push(newBook);
        localStorage.setItem("books", JSON.stringify(books));

        alert(`הלימוד '${newBook.name}' נוסף בהצלחה! הפרק הראשון נטען.`);
        toggleAddBookForm();
        debouncedRenderBooks();
      } catch (err) {
        console.error(err);
        alert("שגיאה בטעינת הטקסט: " + err.message);
      } finally {
        showLoadingIndicator(false);
      }
    }

    // ניהול יום חדש לפי מצבי accumulate/no_accumulate
    function dailyCheck() {
      const today = new Date().toISOString().split("T")[0];
      books.forEach(book => {
        if (book.lastAccessDate !== today) {
          if (book.mode === "accumulate") {
            // במצב accumulate, אין צורך לשנות latestChapterIndex כי הוא כבר מוגדר ל-פרקים כוללים
          } else if (book.mode === "no_accumulate") {
            // במצב no_accumulate, מתקדמים רק אם הפרק האחרון נקרא
            const prevChapter = book.latestChapterIndex;
            if (book.readChapters.includes(prevChapter)) {
              if (book.latestChapterIndex < book.chapters.length - 1) {
                book.latestChapterIndex++;
              }
            }
          }
          book.lastAccessDate = today;
        }
      });
      localStorage.setItem("books", JSON.stringify(books));
    }

    // פונקציית מעבר לקטע הבא
    async function goToNextDay(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      const currentChapter = book.chapters[book.currentChapterIndex];
      if (!currentChapter) return;

      if (book.studyType === 'word') {
        if (book.currentChunkIndex < currentChapter.chunks.length - 1) {
          if (book.mode === "no_accumulate") {
            // במצב no_accumulate, חוסמים התקדמות אם לא סומן כנקרא
            if (!currentChapter.chunks[book.currentChunkIndex].read) {
              alert("יש לסמן את הקטע הנוכחי כנקרא כדי להתקדם.");
              return;
            }
          }
          book.currentChunkIndex++;
        } else {
          // הגיע לסוף הקטע, צריך לעבור לפרק הבא
          const nextChapterIndex = book.currentChapterIndex + 1;

          // במצב 'no_accumulate', רק אם הפרק הנוכחי סומן כנקרא
          if (book.mode === "no_accumulate" && !book.readChapters.includes(book.currentChapterIndex)) {
            alert("יש לסמן את הפרק הנוכחי כנקרא כדי להתקדם לפרק הבא.");
            return;
          }

          // במצב 'accumulate' או במצב 'no_accumulate' ואפשר להתקדם
          if (book.mode === "accumulate" || (book.mode === "no_accumulate" && book.readChapters.includes(book.currentChapterIndex))) {
            // טען את הפרק הבא
            const success = await loadNextChapter(book);
            if (success) {
              book.currentChapterIndex++;
              book.currentChunkIndex = 0;
            } else {
              alert("לא ניתן לטעון פרק נוסף.");
              return;
            }
          } else {
            alert("סיימת את כל הקטעים בספר!");
            return;
          }
        }
      } else if (book.studyType === 'chapter') {
        if (book.currentChunkIndex < book.chapters.length - 1) {
          if (book.mode === "no_accumulate") {
            // במצב no_accumulate, חוסמים התקדמות אם לא סומן כנקרא
            if (!book.chapters[book.currentChunkIndex].read) {
              alert("יש לסמן את הקטע הנוכחי כנקרא כדי להתקדם.");
              return;
            }
          }
          book.currentChunkIndex++;
        } else {
          alert("סיימת את כל הפרקים שהוגדרו ללימוד יומי!");
          return;
        }
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // פונקציית מעבר לקטע הקודם
    function goToPrevDay(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      if (book.studyType === 'word') {
        if (book.currentChunkIndex > 0) {
          book.currentChunkIndex--;
        } else if (book.currentChapterIndex > 0) {
          book.currentChapterIndex--;
          book.currentChunkIndex = book.chapters[book.currentChapterIndex].chunks.length - 1;
        } else {
          alert("אתה כבר נמצא בקטע הראשון.");
          return;
        }
      } else if (book.studyType === 'chapter') {
        if (book.currentChunkIndex > 0) {
          book.currentChunkIndex--;
        } else if (book.currentChapterIndex > 0) {
          book.currentChapterIndex--;
          book.currentChunkIndex = book.chapters[book.currentChapterIndex].chunks.length - 1;
        } else {
          alert("אתה כבר נמצא בקטע הראשון.");
          return;
        }
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // סימון קטע כנקרא (במצב no_accumulate)
    function markChunkAsRead(bookId, chapterIndex, chunkIndex) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      const chapter = book.chapters[chapterIndex];
      if (!chapter) return;

      chapter.chunks[chunkIndex].read = !chapter.chunks[chunkIndex].read;

      if (chapter.chunks[chunkIndex].read) {
        if (!book.readChapters.includes(chapterIndex)) {
          book.readChapters.push(chapterIndex);
        }
      } else {
        book.readChapters = book.readChapters.filter(index => index !== chapterIndex);
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // טעינת פרק הבא מה-API
    async function loadNextChapter(book) {
      const nextChapterNumber = book.chapters.length + 1;
      const chapterPrefix = determineChapterPrefix(book.name, nextChapterNumber);
      const nextChapterIdentifier = getChapterIdentifier(nextChapterNumber, chapterPrefix);

      const apiBookName = book.name.replace(/\s+/g, '_');
      const apiUrl = `https://www.sefaria.org/api/texts/${encodeURIComponent(apiBookName)}.${encodeURIComponent(nextChapterIdentifier)}?lang=he`;

      try {
        showLoadingIndicator(true);
        const data = await fetchWithRetry(apiUrl);

        // חילוץ הטקסט מהתשובה
        const textArray = data.he;

        if (!textArray || textArray.length === 0) {
          alert(`לא ניתן לטעון את הפרק ${nextChapterNumber}.`);
          return false; // אינדיקציה שאין פרקים נוספים
        }

        // הגדרת סעיפים לא רצויים להימנעות מהם
        const unwantedSections = ["הקדמה", "אינדקס", "הערות", "סיכומים", "תודות", "ספרות", "עריכה", "פרקים"];

        // סינון הפסקאות כדי להתחיל מדברי המחבר בלבד
        const processedParagraphs = [];
        let skip = true;
        let currentChapter = chapterPrefix; // ברירת מחדל

        for (let para of textArray) {
          // בדיקה אם הפסקה מתחילה באחד הסעיפים הלא רצויים
          if (unwantedSections.some(section => para.startsWith(section))) {
            skip = true;
            continue;
          }

          // בדיקה אם הפסקה מתחילה בפרק (אם יש פרקים בתוך הפרק)
          const chapterMatch = para.match(new RegExp(`^(${chapterPrefixes.join('|')})\\s*\\w+`));
          if (chapterMatch) {
            currentChapter = para.trim();
            skip = false;
            continue; // לא כולל את כותרת הפרק כפרק
          }

          // בדיקה אם הפסקה אינה חלק מהסעיפים הלא רצויים
          if (skip && !unwantedSections.some(section => para.startsWith(section))) {
            skip = false;
          }

          if (!skip) {
            processedParagraphs.push({ text: para, chapter: currentChapter });
          }
        }

        if (processedParagraphs.length === 0) {
          throw new Error(`לא אותרו פסקאות או שהטקסט ריק לאחר הסינון בפרק ${nextChapterNumber}.`);
        }

        // חלוקה לקטעים
        const chaptersMap = {}; // מיפוי פרקים לטקסט שלהם
        processedParagraphs.forEach(para => {
          if (!chaptersMap[para.chapter]) {
            chaptersMap[para.chapter] = [];
          }
          chaptersMap[para.chapter].push(para.text);
        });

        // יצירת רשימת פרקים
        const chaptersList = Object.keys(chaptersMap).map((chapterName, index) => ({
          chapterNumber: nextChapterNumber,
          text: chaptersMap[chapterName].join('\n\n'),
          chunks: book.studyType === 'word' ? splitIntoChunks(chaptersMap[chapterName].join('\n\n'), book.wordCount, 'word') : splitIntoChunks(chaptersMap[chapterName].join('\n\n'), book.chapterCount, 'chapter')
        }));

        if (chaptersList.length === 0) {
          throw new Error(`לא נמצאו פרקים לטעינה בפרק ${nextChapterNumber}.`);
        }

        // הוספת הפרק החדש לספר
        book.chapters.push({
          chapterNumber: nextChapterNumber,
          text: chaptersList[0].text,
          chunks: chaptersList[0].chunks
        });

        // עדכון latestChapterIndex במצב 'no_accumulate' אם רלוונטי
        if (book.mode === "accumulate") {
          book.latestChapterIndex = book.chapters.length - 1;
        }

        localStorage.setItem("books", JSON.stringify(books));
        return true; // הצלחה
      } catch (err) {
        console.error(err);
        alert(`שגיאה בטעינת הפרק הבא: ${err.message}`);
        return false;
      } finally {
        showLoadingIndicator(false);
      }
    }

    // פונקציה לחישוב התחילית של הפרק הבא בהתאם לסוג הפרק
    function determineChapterPrefix(bookName, chapterNumber) {
      // לדוגמה, עבור 'קיצור שולחן ערוך', הפרקים הם 'סימן א', 'סימן ב', וכו'
      // עבור 'מסילת ישרים', הפרקים הם 'פרק 1', 'פרק 2', וכו'
      // כאן נשתמש בלוגיקה פשוטה, אבל ניתן להתאים לפי הספרים השונים
      if (bookName.includes("קיצור שולחן ערוך")) {
        const letters = ['א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ז', 'ח', 'ט', 'י', 'כ', 'ל', 'מ', 'נ', 'ס', 'ע', 'פ', 'צ', 'ק', 'ר', 'ש', 'ת'];
        if (chapterNumber - 1 < letters.length) {
          return `סימן ${letters[chapterNumber - 1]}`;
        }
      }
      // ניתן להוסיף תנאים נוספים עבור ספרים אחרים עם תחיליות מיוחדות

      // ברירת מחדל לפרקים מספריים
      return `פרק ${chapterNumber}`;
    }

    // פונקציה לחישוב מזהה הפרק הבא בהתאם לפרופיל הספר
    function getChapterIdentifier(chapterNumber, chapterPrefix) {
      // לדוגמה, עבור 'מסילת ישרים' מזהה הפרק הוא 'פרק 1'
      // עבור 'קיצור שולחן ערוך', מזהה הפרק הוא 'סימן א'
      return chapterPrefix;
    }

    // הצגת לימודים פעילים
    function renderBooks() {
      const container = document.getElementById("booksContainer");
      container.innerHTML = "";

      if (books.length === 0) {
        container.innerHTML = "<p>לא הוספת לימודים עדיין.</p>";
        return;
      }

      books.forEach(book => {
        // במצב 'accumulate', נציג את כל הקטעים הלא מסומנים כנלמדים
        // במצב 'no_accumulate', נציג רק את הקטעים הנוכחיים והלא מסומנים
        let chaptersToDisplay = [];

        if (book.mode === "accumulate") {
          chaptersToDisplay = book.chapters;
        } else if (book.mode === "no_accumulate") {
          chaptersToDisplay = book.chapters.filter((chapter, index) => !book.readChapters.includes(index));
        }

        chaptersToDisplay.forEach(chapter => {
          const bookDiv = document.createElement("div");
          bookDiv.className = "bookContainer";

          // כותרת
          const titleDiv = document.createElement("div");
          titleDiv.className = "bookTitle";

          // הצגת שם הספר ופרק אם קיים
          if (chapter.chapterNumber) {
            titleDiv.textContent = `${book.name} - ${chapter.chapterNumber}`;
          } else {
            titleDiv.textContent = `${book.name}`;
          }

          // הוספת רובריקה לסימון כנלמד במצב 'accumulate'
          if (book.mode === "accumulate") {
            const markReadContainer = document.createElement("div");
            markReadContainer.className = "markReadContainer";

            const checkbox = document.createElement("div");
            checkbox.className = `markReadCheckbox ${chapter.read ? 'checked' : ''}`;
            checkbox.onclick = () => {
              markChunkAsRead(book.id, book.chapters.indexOf(chapter), 0);
            };

            const label = document.createElement("span");
            label.className = "markReadLabel";
            label.textContent = "סמן כנלמד";
            label.onclick = () => {
              checkbox.click();
            };

            markReadContainer.appendChild(checkbox);
            markReadContainer.appendChild(label);
            titleDiv.appendChild(markReadContainer);
          }

          titleDiv.onclick = () => toggleChunkDisplay(book.id, chapter.chapterNumber);
          bookDiv.appendChild(titleDiv);

          // הטקסט עצמו
          const chunkP = document.createElement("p");
          chunkP.className = "chunkText";
          chunkP.id = `chunk-${book.id}-${chapter.chapterNumber}`;
          chunkP.textContent = `${chapter.chapterNumber ? chapter.chapterNumber : ''}\n\n${chapter.text}`;
          bookDiv.appendChild(chunkP);

          // כפתורי ניווט + סימון + מחיקה
          const btnRow = document.createElement("div");
          btnRow.className = "btnRow";

          // כפתור "הקודם"
          const prevBtn = document.createElement("button");
          prevBtn.className = "navigationBtn";
          prevBtn.textContent = "הקודם";
          prevBtn.onclick = () => goToPrevDay(book.id);
          btnRow.appendChild(prevBtn);

          // כפתור "הבא"
          const nextBtn = document.createElement("button");
          nextBtn.className = "navigationBtn";
          nextBtn.textContent = "הבא";
          nextBtn.onclick = () => goToNextDay(book.id);
          btnRow.appendChild(nextBtn);

          // כפתור "סמן כנלמד" במצב 'no_accumulate'
          if (book.mode === "no_accumulate") {
            const markBtn = document.createElement("button");
            markBtn.className = "markReadBtn";
            markBtn.textContent = "סמן כנלמד";
            markBtn.onclick = () => markChunkAsRead(book.id, book.chapters.indexOf(chapter), 0);
            btnRow.appendChild(markBtn);
          }

          bookDiv.appendChild(btnRow);

          // כפתור הסרה
          const removeRow = document.createElement("div");
          removeRow.className = "btnRow";
          const removeBtn = document.createElement("button");
          removeBtn.className = "removeBtn";
          removeBtn.textContent = "הסר לימוד זה";
          removeBtn.onclick = () => removeBook(book.id);
          removeRow.appendChild(removeBtn);
          bookDiv.appendChild(removeRow);

          // הוספת קו מפריד
          const separator = document.createElement("div");
          separator.className = "separator";
          bookDiv.appendChild(separator);

          container.appendChild(bookDiv);
        });
      });
    }

    // פונקציה להציג/להסתיר את קטע הלימוד
    function toggleChunkDisplay(bookId, chapterNumber) {
      const chunkP = document.getElementById(`chunk-${bookId}-${chapterNumber}`);
      if (!chunkP) return;
      if (chunkP.style.display === "none" || chunkP.style.display === "") {
        chunkP.style.display = "block";
      } else {
        chunkP.style.display = "none";
      }
    }

    // פונקציה להסרת לימוד
    function removeBook(bookId) {
      if (!confirm("האם אתה בטוח שברצונך להסיר את הלימוד הזה?")) return;
      books = books.filter(b => b.id !== bookId);
      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // חישוב סטטיסטיקות למשתמש
    function calculateStatistics(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return null;
      
      const totalChunks = book.chapters.reduce((sum, chapter) => 
        sum + (book.studyType === 'word' ? chapter.chunks.length : 1), 0);
      
      const readChunks = book.chapters.reduce((sum, chapter) => 
        sum + chapter.chunks.filter(chunk => chunk.read).length, 0);
      
      return {
        progress: Math.round((readChunks / totalChunks) * 100),
        daysActive: book.readChapters.length,
        averageWordsPerDay: book.readChapters.length > 0 ? Math.round((readChunks * (book.studyType === 'word' ? book.wordCount : 300)) / book.readChapters.length) : 0,
        estimatedCompletion: Math.ceil((totalChunks - readChunks) * (book.studyType === 'word' ? book.wordCount : 300) / (book.studyType === 'word' ? book.wordCount : 300))
      };
    }

    // קיצורי מקלדת
    function setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        
        switch(e.key) {
          case 'ArrowRight':
            if (e.ctrlKey) {
              const bookId = getCurrentBookId();
              if (bookId) goToNextDay(bookId);
            }
            break;
          case 'ArrowLeft':
            if (e.ctrlKey) {
              const bookId = getCurrentBookId();
              if (bookId) goToPrevDay(bookId);
            }
            break;
          case 'm':
            if (e.ctrlKey) {
              const bookId = getCurrentBookId();
              if (bookId) markCurrentChunkAsRead(bookId);
            }
            break;
        }
      });
    }

    // פונקציה לקבלת מזהה הספר הנוכחי (לדוגמה, הספר הראשון)
    function getCurrentBookId() {
      if (books.length > 0) return books[0].id;
      return null;
    }

    // סימון הקטע הנוכחי כנקרא דרך קיצור מקלדת
    function markCurrentChunkAsRead(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;
      markChunkAsRead(bookId, book.currentChapterIndex, book.currentChunkIndex);
    }

    // תמיכה במובייל - סוואיפים
    function setupMobileSwipeSupport() {
      let touchstartX = 0;
      let touchendX = 0;
      
      document.addEventListener('touchstart', e => {
        touchstartX = e.changedTouches[0].screenX;
      });
      
      document.addEventListener('touchend', e => {
        touchendX = e.changedTouches[0].screenX;
        handleSwipe();
      });
      
      function handleSwipe() {
        const diff = touchendX - touchstartX;
        if (Math.abs(diff) < 50) return;
        
        const bookId = getCurrentBookId();
        if (!bookId) return;
        
        if (diff > 0) {
          goToPrevDay(bookId);
        } else {
          goToNextDay(bookId);
        }
      }
    }

    // בעת טעינת הדף
    window.onload = function() {
      // שינוי תצוגת הטופס בהתאם לסוג הלימוד
      document.getElementById('studyType').addEventListener('change', function() {
        if (this.value === 'word') {
          document.getElementById('wordCountContainer').style.display = 'block';
          document.getElementById('chapterCountContainer').style.display = 'none';
          document.getElementById('wordCount').required = true;
          document.getElementById('chapterCount').required = false;
        } else {
          document.getElementById('wordCountContainer').style.display = 'none';
          document.getElementById('chapterCountContainer').style.display = 'block';
          document.getElementById('wordCount').required = false;
          document.getElementById('chapterCount').required = true;
        }
      });

      dailyCheck();
      renderBooks();
      setupKeyboardShortcuts();
      setupMobileSwipeSupport();
    };
  </script>
</body>
</html>
