<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>הלימוד היומי</title>
  <style>
    body {
      font-family: "Alef", sans-serif;
      background: linear-gradient(to bottom, #e3f2fd, #90caf9);
      color: #333;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .box {
      margin: 20px auto;
      max-width: 800px;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    h2 {
      margin-top: 0;
    }
    #toggleAddBookBtn {
      display: block;
      width: 100%;
      margin: 20px auto;
      padding: 15px;
      border: none;
      border-radius: 5px;
      background: #2ecc71;
      color: #fff;
      font-size: 1.1rem;
      cursor: pointer;
      text-align: center;
      transition: background 0.3s;
    }
    #toggleAddBookBtn:hover {
      background: #27ae60;
    }
    #addBookContainer {
      display: none;
    }
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
    }
    input, select, button {
      width: 100%;
      margin-bottom: 15px;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
      font-size: 1rem;
      box-sizing: border-box;
    }
    button {
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    .bookContainer {
      margin-bottom: 20px;
      border-bottom: 1px solid #ccc;
      padding-bottom: 10px;
    }
    .bookTitle {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 1.2rem;
      cursor: pointer;
      color: #2980b9;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .bookTitle:hover {
      text-decoration: underline;
    }
    .expandedChunksContainer {
      margin-top: 10px;
      display: none; /* מוסתר כברירת מחדל */
    }
    .singleChunkContainer {
      border-bottom: 1px solid #ccc;
      padding: 10px 0;
      margin-bottom: 10px;
    }
    .chunkText {
      margin: 10px 0;
      font-size: 1rem;
      line-height: 1.6;
      white-space: pre-line;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      font-size: 1rem;
    }
    .checkbox-container input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: #3498db;
      cursor: pointer;
      position: relative;
      appearance: none;
      border: 2px solid #ccc;
      border-radius: 4px;
      outline: none;
      transition: background-color 0.3s, border-color 0.3s;
    }
    .checkbox-container input[type="checkbox"]:checked {
      background-color: #3498db;
      border-color: #3498db;
    }
    .checkbox-container input[type="checkbox"]:checked::after {
      content: '✔';
      position: absolute;
      top: 0;
      left: 4px;
      color: #fff;
      font-size: 16px;
    }

    /* כפתורי ניווט, מחיקה וכו' */
    .btnRow {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
    }
    .navigationBtn,
    .removeBtn {
      padding: 8px 16px;
      font-size: 0.9rem;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #fff;
      transition: background 0.3s;
    }
    .navigationBtn {
      background: #3498db;
    }
    .navigationBtn:hover {
      background: #2980b9;
    }
    .removeBtn {
      background: #e74c3c;
    }
    .removeBtn:hover {
      background: #c0392b;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      font-size: 1.5rem;
      color: #3498db;
    }
    @media (max-width: 600px) {
      .box {
        max-width: 90%;
      }
      #toggleAddBookBtn {
        max-width: 90%;
      }
    }
  </style>
</head>
<body dir="rtl">
  <h1>הלימוד היומי</h1>

  <!-- כפתור לפתיחת הטופס להוספת לימוד -->
  <button id="toggleAddBookBtn" onclick="toggleAddBookForm()">
    הוספת לימוד יומי מתוך ספר
  </button>

  <!-- תיבה מוסתרת עם טופס הוספת לימוד -->
  <div id="addBookContainer" class="box">
    <h2>טופס הוספת לימוד יומי</h2>
    <label for="bookName">שם הספר (למשל: מסילת ישרים):</label>
    <input type="text" id="bookName" placeholder="מסילת ישרים" required />

    <label for="wordCount">כמות מילים יומית (לדוגמה: 300):</label>
    <input type="number" id="wordCount" placeholder="300" min="1" required />

    <label for="mode">מצב לימוד:</label>
    <select id="mode">
      <option value="accumulate">חובות מצטברים</option>
      <option value="block">בלוק (לא מתקדם בלי סימון)</option>
    </select>

    <button onclick="addBook()">הוסף לימוד</button>
  </div>

  <!-- תיבה להצגת הלימודים הפעילים -->
  <div id="content" class="box">
    <h2>לימודים פעילים</h2>
    <div id="booksContainer">
      <p>לא הוספת לימודים עדיין.</p>
    </div>
  </div>

  <!-- אינדיקטור טעינה -->
  <div id="loadingIndicator" class="loading-overlay" style="display: none;">
    טוען...
  </div>

  <script>
    /*
      מבנה הנתונים במערך books לאחר השדרוג:
      books = [
        {
          id: מזהה ייחודי (Date.now()),
          name: "מסילת ישרים",
          mode: "accumulate" | "block",
          wordCount: 300,
          chapters: [ 
            {
              chapterNumber: 1, 
              chapterIdentifier: "פרק א'",
              text: "...",
              chunks: [ { text: "...", read: false }, ... ],
            },
            ...
          ],
          // בשימוש בעיקר למצב block:
          currentChapterIndex: 0,
          currentChunkIndex: 0,
          latestChapterIndex: 0, 
          readChapters: [], // במצב 'block'
          
          // בשימוש בעיקר למצב accumulate:
          dailyChunks: [
            { date: "2025-01-01", chapterIndex: 0, chunkIndex: 0, read: false },
            { date: "2025-01-02", chapterIndex: 0, chunkIndex: 1, read: false },
            ...
          ],

          lastAccessDate: "2025-01-01"
        }
      ]
    */

    let books = JSON.parse(localStorage.getItem("books")) || [];

    // פונקציה עם ריטריי וטיימאאוט לבקשות API
    async function fetchWithRetry(url, maxRetries = 3, timeout = 5000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, { signal: controller.signal });
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.json();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        }
      }
    }

    // מטמון לעיבוד הטקסט
    const textProcessingCache = new Map();

    function processText(text, wordCount) {
      const cacheKey = `${text.slice(0, 100)}_${wordCount}`;
      if (textProcessingCache.has(cacheKey)) {
        return textProcessingCache.get(cacheKey);
      }

      const chunks = splitIntoChunks(text, wordCount);
      textProcessingCache.set(cacheKey, chunks);
      
      // ניקוי המטמון אם גדול מדי
      if (textProcessingCache.size > 100) {
        const firstKey = textProcessingCache.keys().next().value;
        textProcessingCache.delete(firstKey);
      }
      
      return chunks;
    }

    // חלוקת טקסט לקטעים לפי מספר מילים
    function splitIntoChunks(text, wordCount) {
      const paragraphs = text.split(/\n{2,}/).filter(p => p.trim() !== '');
      const chunks = [];
      let currentChunk = "";
      let currentWords = 0;

      for (let para of paragraphs) {
        const pWords = para.split(/\s+/).filter(Boolean).length;
        if (currentWords + pWords <= wordCount) {
          currentChunk += (currentChunk ? "\n\n" : "") + para;
          currentWords += pWords;
        } else {
          if (currentChunk) {
            chunks.push({ text: currentChunk, read: false });
          }
          currentChunk = para;
          currentWords = pWords;
        }
      }

      if (currentChunk) {
        chunks.push({ text: currentChunk, read: false });
      }

      return chunks;
    }

    // ולידציה משופרת
    function validateBookInput(bookName, wordCount) {
      const errors = [];
      
      if (!bookName || bookName.length < 2) {
        errors.push("שם הספר חייב להכיל לפחות 2 תווים.");
      }
      
      if (!wordCount || wordCount < 50 || wordCount > 1000) {
        errors.push("מספר המילים חייב להיות בין 50 ל-1000.");
      }
      
      if (/[<>%$]/.test(bookName)) {
        errors.push("שם הספר מכיל תווים לא חוקיים (כמו <, >, %, $).");
      }
      
      return errors;
    }

    // דיבאונס לרינדור (מניעת רינדורים תכופים)
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    const debouncedRenderBooks = debounce(renderBooks, 250);

    // מציג/מסתיר את טופס הוספת לימוד
    function toggleAddBookForm() {
      const container = document.getElementById("addBookContainer");
      if (container.style.display === "none" || container.style.display === "") {
        container.style.display = "block";
      } else {
        container.style.display = "none";
      }
    }

    // פונקציה להראות/להסתיר אינדיקטור טעינה
    function showLoadingIndicator(show) {
      const loadingDiv = document.getElementById('loadingIndicator');
      loadingDiv.style.display = show ? 'flex' : 'none';
    }

    // הגדרת מיפוי ספרים לתחיליות הפרקים שלהם (ניתן להרחיב כאן)
    const bookMappings = {
      "מסילת ישרים": {
        prefixType: "hebrewLetters",
        prefixWord: "פרק"
      },
      "קיצור שולחן ערוך": {
        prefixType: "hebrewLetters",
        prefixWord: "סימן"
      },
      // ניתן להוסיף ספרים נוספים כאן
    };

    // פונקציה להמרת מספרים לאותיות עבריות
    function numberToHebrew(number) {
      const units = ['', 'א', 'ב', 'ג', 'ד', 'ה', 'ו', 'ז', 'ח', 'ט'];
      const tens = ['', 'י', 'כ', 'ל', 'מ', 'נ', 'ס', 'ע', 'פ', 'צ'];
      if (number === 0) return '';
      let result = '';
      if (number >= 10) {
        let ten = Math.floor(number / 10);
        let unit = number % 10;

        // טיפול במקרים מיוחדים של 15 ו-16
        if (ten === 1 && (unit === 5 || unit === 6)) {
          return (unit === 5) ? 'טו' : 'טז';
        }

        if (ten > 0) {
          result += tens[ten];
        }

        if (unit > 0) {
          result += units[unit];
        }
      } else {
        result += units[number];
      }
      return result;
    }

    // פונקציה לחישוב התחילית של הפרק בהתאם למיפוי הספר
    function determineChapterPrefix(bookName, chapterNumber) {
      if (bookMappings[bookName]) {
        const mapping = bookMappings[bookName];
        if (mapping.prefixType === "hebrewLetters") {
          const hebrewNumber = numberToHebrew(chapterNumber);
          return `${mapping.prefixWord} ${hebrewNumber}`;
        }
      }
      // ברירת מחדל לפרקים מספריים
      return `פרק ${chapterNumber}`;
    }

    // פונקציה לחישוב מזהה הפרק בהתאם לפרופיל הספר
    function getChapterIdentifier(bookName, chapterNumber) {
      return determineChapterPrefix(bookName, chapterNumber);
    }

    // הוספת לימוד חדש
    async function addBook() {
      const bookNameInput = document.getElementById("bookName").value.trim();
      const wordCount = parseInt(document.getElementById("wordCount").value);
      const mode = document.getElementById("mode").value;

      // ולידציה
      const validationErrors = validateBookInput(bookNameInput, wordCount);
      if (validationErrors.length > 0) {
        alert(validationErrors.join("\n"));
        return;
      }

      // המרת שם הספר לפורמט שמתאים ל-API של ספריא
      const apiBookName = bookNameInput.replace(/\s+/g, '_');

      try {
        showLoadingIndicator(true);

        // נסה לטעון את הספר מה-API
        const apiUrl = `https://www.sefaria.org/api/texts/${encodeURIComponent(apiBookName)}?lang=he`;
        const data = await fetchWithRetry(apiUrl);

        // חילוץ הטקסט
        const textArray = data.he;

        if (!textArray || textArray.length === 0) {
          throw new Error("לא אותרו פסקאות או שהטקסט ריק.");
        }

        // חלוקה לפרקים (בשלב ראשון - פרק 1 בלבד)
        // אצל חלק מהספרים ב-Sefaria, data.he יכול להיות המון טקסט של כל הספר.  
        // לצורך הפשטות נשתמש רק במידע שהגיע כ"פרק ראשון". אם רוצים לטעון הכל נדרשת לוגיקה נוספת.
        const allText = textArray.join('\n\n');
        const chapterChunks = splitIntoChunks(allText, wordCount);

        const newBook = {
          id: Date.now(),
          name: apiBookName.replace(/_/g, ' '), // השם המקורי
          mode: mode,
          wordCount: wordCount,
          chapters: [
            {
              chapterNumber: 1,
              chapterIdentifier: getChapterIdentifier(bookNameInput, 1),
              text: allText,
              chunks: chapterChunks
            }
          ],
          currentChapterIndex: 0,
          currentChunkIndex: 0,
          latestChapterIndex: 0,
          readChapters: [],

          // מערך יומי - בשימוש למצב accumulate
          dailyChunks: [],
          
          lastAccessDate: ""
        };

        // בשלב הבא אם רוצים לטעון בהמשכים פרקים נוספים מהספר - יש פונקציות בהמשך (loadNextChapter)...

        books.push(newBook);
        localStorage.setItem("books", JSON.stringify(books));

        alert(`הלימוד '${newBook.name}' נוסף בהצלחה! הפרק הראשון נטען.`);
        toggleAddBookForm();
        debouncedRenderBooks();
      } catch (err) {
        console.error(err);
        alert("שגיאה בטעינת הטקסט: " + err.message);
      } finally {
        showLoadingIndicator(false);
      }
    }

    // פונקציה ייעודית למצב accumulate: בכל יום חדש מוסיפים "עוד קטע"
    // אם סיימנו את הפרק הנוכחי, נטען פרק חדש.
    async function addDailyChunkAccumulate(book) {
      // נאתר את היום הנוכחי
      const today = new Date().toISOString().split("T")[0];
      // אם כבר נוספו קטעים היום – לא מוסיפים שוב
      const alreadyAdded = book.dailyChunks.find(dc => dc.date === today);
      if (alreadyAdded) return;

      const lastDaily = book.dailyChunks[book.dailyChunks.length - 1];

      // אם אין בכלל dailyChunks (היום הראשון), נתחיל מ chunkIndex=0, chapterIndex=0
      let chapterIndex = 0;
      let chunkIndex = 0;

      if (lastDaily) {
        chapterIndex = lastDaily.chapterIndex;
        chunkIndex = lastDaily.chunkIndex + 1; // עוברים לקטע הבא
      }

      // אם חרגנו מכמות הקטעים בפרק הנוכחי – נטען פרק חדש מה-API
      if (book.chapters[chapterIndex] && chunkIndex >= book.chapters[chapterIndex].chunks.length) {
        const success = await loadNextChapter(book);
        if (!success) {
          // אין עוד פרקים לטעון
          return;
        } else {
          chapterIndex = book.chapters.length - 1; // הפרק האחרון שזה עתה נטען
          chunkIndex = 0;
        }
      }

      // עכשיו נוסיף את הקטע היומי
      book.dailyChunks.push({
        date: today,
        chapterIndex,
        chunkIndex,
        read: false
      });
    }

    // ניהול יום חדש לפי מצבי accumulate/block
    async function dailyCheck() {
      const today = new Date().toISOString().split("T")[0];

      for (const book of books) {
        // אם כבר ביצענו עדכון היום – דלג
        if (book.lastAccessDate === today) {
          continue;
        }

        if (book.mode === "accumulate") {
          // בכל יום מוסיפים קטע חדש (אם יש)
          await addDailyChunkAccumulate(book);
        } 
        else if (book.mode === "block") {
          // במצב block, מתקדמים רק אם הפרק האחרון נקרא
          const prevChapter = book.latestChapterIndex;
          if (book.readChapters.includes(prevChapter)) {
            if (book.latestChapterIndex < book.chapters.length - 1) {
              book.latestChapterIndex++;
            }
          }
        }

        book.lastAccessDate = today;
      }

      localStorage.setItem("books", JSON.stringify(books));
    }

    // טעינת פרק הבא מה-API (לשימוש גם במצב accumulate אם מגיעים לסוף פרק)
    async function loadNextChapter(book) {
      const nextChapterNumber = book.chapters.length + 1;
      const nextChapterIdentifier = getChapterIdentifier(book.name, nextChapterNumber);

      const apiBookName = book.name.replace(/\s+/g, '_');
      const apiUrl = `https://www.sefaria.org/api/texts/${encodeURIComponent(apiBookName)}.${encodeURIComponent(nextChapterNumber)}?lang=he`;
      // חלק מהספרים בספריא דורשים בניית URL אחרת, לדוגמה "ספר_פרק_פסוק" אבל נניח שזה מספיק לדוגמה.

      try {
        showLoadingIndicator(true);
        const data = await fetchWithRetry(apiUrl);

        const textArray = data.he;
        if (!textArray || textArray.length === 0) {
          alert(`לא ניתן לטעון את הפרק ${nextChapterIdentifier}. ייתכן שזה סוף הספר.`);
          return false;
        }

        // ממיר למחרוזת אחת
        const allText = textArray.join('\n\n');
        const newChunks = splitIntoChunks(allText, book.wordCount);

        book.chapters.push({
          chapterNumber: nextChapterNumber,
          chapterIdentifier: nextChapterIdentifier,
          text: allText,
          chunks: newChunks
        });

        if (book.mode === "accumulate") {
          // אין צורך לעדכן אחר, כי dailyChunks כבר יידעו לקחת את הפרק הזה מחר.
        } else if (book.mode === "block") {
          // במצב block נעשה שה latestChapterIndex יהיה הפרק האחרון הזמין
          book.latestChapterIndex = book.chapters.length - 1;
        }

        localStorage.setItem("books", JSON.stringify(books));
        return true;
      } catch (err) {
        console.error(err);
        alert(`שגיאה בטעינת הפרק הבא: ${err.message}`);
        return false;
      } finally {
        showLoadingIndicator(false);
      }
    }

    // סימון קטע כנקרא (משמש גם ל־block וגם ל־accumulate, פשוט משנה נתונים שונים)
    function toggleChunkRead(bookId, chapterIndex, chunkIndex, dateForAccumulate = null) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      if (book.mode === "block") {
        // סימון במערך chunks
        book.chapters[chapterIndex].chunks[chunkIndex].read = 
          !book.chapters[chapterIndex].chunks[chunkIndex].read;

        // אם הפרק כולו נקרא – נוסיף אותו ל־readChapters
        if (book.chapters[chapterIndex].chunks.every(ch => ch.read)) {
          if (!book.readChapters.includes(chapterIndex)) {
            book.readChapters.push(chapterIndex);
          }
        }
      } 
      else if (book.mode === "accumulate") {
        // מוצאים את dailyChunk הרלוונטי
        const dailyChunk = book.dailyChunks.find(dc => 
          dc.date === dateForAccumulate &&
          dc.chapterIndex === chapterIndex &&
          dc.chunkIndex === chunkIndex
        );
        if (!dailyChunk) return;

        dailyChunk.read = !dailyChunk.read;

        // בנוסף נסמן גם ב-chunks עצמם
        book.chapters[chapterIndex].chunks[chunkIndex].read = dailyChunk.read;

        // אם dailyChunk נקרא – הוא לא יופיע מחר.  
        // הקוד ברינדור מסנן אוטומטית dailyChunks שנקראו, רק ביום הרלוונטי הוא יוצג.
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // הצגת לימודים פעילים
    function renderBooks() {
      const container = document.getElementById("booksContainer");
      container.innerHTML = "";

      if (books.length === 0) {
        container.innerHTML = "<p>לא הוספת לימודים עדיין.</p>";
        return;
      }

      books.forEach(book => {
        const bookDiv = document.createElement("div");
        bookDiv.className = "bookContainer";

        // כותרת
        const titleDiv = document.createElement("div");
        titleDiv.className = "bookTitle";

        // מה יוצג בכותרת?
        let titleText = book.name;
        if (book.mode === "block") {
          // מציגים את הקטע הנוכחי (בהנחה שלא חרגנו)
          const ch = book.chapters[book.currentChapterIndex];
          if (!ch) {
            titleText += " (לא נותרו פרקים)";
          } else {
            const currentChunk = ch.chunks[book.currentChunkIndex];
            titleText += ` - ${ch.chapterIdentifier} קטע ${book.currentChunkIndex + 1} מתוך ${ch.chunks.length}`;
          }
        } else if (book.mode === "accumulate") {
          // נזהה את הקטע של היום (אם נוסף)
          const today = new Date().toISOString().split("T")[0];
          const todayChunk = book.dailyChunks.find(dc => dc.date === today);
          if (todayChunk) {
            const ch = book.chapters[todayChunk.chapterIndex];
            titleText += ` - ${ch.chapterIdentifier} קטע ${todayChunk.chunkIndex + 1} מתוך ${ch.chunks.length}`;
          } else {
            titleText += " (עוד לא נוסף קטע להיום או סוף הספר)";
          }
        }

        titleDiv.textContent = titleText;

        // בעת לחיצה על הכותרת נפתח/נסגור את האזור שמציג את כל המקטעים
        titleDiv.onclick = () => toggleExpand(book.id);
        bookDiv.appendChild(titleDiv);

        // אזור שמכיל את כל המקטעים (במצב block: רק הקטע הנוכחי, במצב accumulate: כל הקטעים הלא נקראים)
        const expandedDiv = document.createElement("div");
        expandedDiv.className = "expandedChunksContainer";
        expandedDiv.id = `expanded-${book.id}`;

        if (book.mode === "block") {
          const ch = book.chapters[book.currentChapterIndex];
          if (ch) {
            const singleChunkDiv = document.createElement("div");
            singleChunkDiv.className = "singleChunkContainer";

            const chunkTextP = document.createElement("p");
            chunkTextP.className = "chunkText";
            chunkTextP.textContent = ch.chunks[book.currentChunkIndex].text;
            singleChunkDiv.appendChild(chunkTextP);

            // צ'קבוקס סימון
            const checkboxContainer = document.createElement("div");
            checkboxContainer.className = "checkbox-container";
            const checkboxId = `checkbox-${book.id}-${book.currentChapterIndex}-${book.currentChunkIndex}`;

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.id = checkboxId;
            checkbox.checked = ch.chunks[book.currentChunkIndex].read;
            checkbox.onclick = () => toggleChunkRead(book.id, book.currentChapterIndex, book.currentChunkIndex);

            const checkboxLabel = document.createElement("label");
            checkboxLabel.setAttribute("for", checkboxId);
            checkboxLabel.textContent = "סמן כנלמד";

            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(checkboxLabel);

            singleChunkDiv.appendChild(checkboxContainer);

            expandedDiv.appendChild(singleChunkDiv);
          }

          // כפתורי הבא/הקודם/הסר
          const btnRow = document.createElement("div");
          btnRow.className = "btnRow";

          const prevBtn = document.createElement("button");
          prevBtn.textContent = "הקודם";
          prevBtn.className = "navigationBtn";
          prevBtn.onclick = () => goToPrevDay(book.id);

          const nextBtn = document.createElement("button");
          nextBtn.textContent = "הבא";
          nextBtn.className = "navigationBtn";
          nextBtn.onclick = () => goToNextDay(book.id);

          btnRow.appendChild(prevBtn);
          btnRow.appendChild(nextBtn);

          expandedDiv.appendChild(btnRow);
        }
        else if (book.mode === "accumulate") {
          // נציג את כל הקטעים היומיים (מישן לישן) שעדיין לא סומנו כנקראים
          // נמיין לפי תאריך
          const sortedDailyChunks = book.dailyChunks
            .filter(dc => !dc.read)  // רק קטעים שלא נקראו
            .sort((a, b) => a.date.localeCompare(b.date));  // מישן לחדש

          if (sortedDailyChunks.length === 0) {
            // אין מקטעים לא נקראים
            const noChunksP = document.createElement("p");
            noChunksP.textContent = "אין מקטעי לימוד לא נקראים (השלמת הכל).";
            expandedDiv.appendChild(noChunksP);
          } else {
            sortedDailyChunks.forEach(dc => {
              const ch = book.chapters[dc.chapterIndex];
              if (!ch) return;

              const singleChunkDiv = document.createElement("div");
              singleChunkDiv.className = "singleChunkContainer";

              // כותרת יום
              const dateTitle = document.createElement("h4");
              dateTitle.textContent = `תאריך: ${dc.date} — ${ch.chapterIdentifier} קטע ${dc.chunkIndex+1} מתוך ${ch.chunks.length}`;
              singleChunkDiv.appendChild(dateTitle);

              // טקסט הקטע
              const chunkTextP = document.createElement("p");
              chunkTextP.className = "chunkText";
              chunkTextP.textContent = ch.chunks[dc.chunkIndex].text;
              singleChunkDiv.appendChild(chunkTextP);

              // צ'קבוקס סימון
              const checkboxContainer = document.createElement("div");
              checkboxContainer.className = "checkbox-container";
              const checkboxId = `checkbox-${book.id}-${dc.chapterIndex}-${dc.chunkIndex}-${dc.date}`;

              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.id = checkboxId;
              checkbox.checked = dc.read;
              checkbox.onclick = () => toggleChunkRead(book.id, dc.chapterIndex, dc.chunkIndex, dc.date);

              const checkboxLabel = document.createElement("label");
              checkboxLabel.setAttribute("for", checkboxId);
              checkboxLabel.textContent = "סמן כנלמד";

              checkboxContainer.appendChild(checkbox);
              checkboxContainer.appendChild(checkboxLabel);

              singleChunkDiv.appendChild(checkboxContainer);

              expandedDiv.appendChild(singleChunkDiv);
            });
          }
        }

        // כפתור הסרה (נראה לכולם)
        const removeRow = document.createElement("div");
        removeRow.className = "btnRow";
        const removeBtn = document.createElement("button");
        removeBtn.className = "removeBtn";
        removeBtn.textContent = "הסר לימוד זה";
        removeBtn.onclick = () => removeBook(book.id);
        removeRow.appendChild(removeBtn);

        expandedDiv.appendChild(removeRow);

        bookDiv.appendChild(expandedDiv);
        container.appendChild(bookDiv);
      });
    }

    // הצגה/הסתרה של כל המקטעים (בלחיצה על הכותרת)
    function toggleExpand(bookId) {
      const expandedDiv = document.getElementById(`expanded-${bookId}`);
      if (!expandedDiv) return;

      if (expandedDiv.style.display === "none" || expandedDiv.style.display === "") {
        expandedDiv.style.display = "block";
      } else {
        expandedDiv.style.display = "none";
      }
    }

    // פונקציית מעבר לקטע הבא (במצב block)
    async function goToNextDay(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      if (book.mode !== "block") return; // לא רלוונטי במצב accumulate

      const currentChapter = book.chapters[book.currentChapterIndex];
      if (!currentChapter) return;

      if (book.currentChunkIndex < currentChapter.chunks.length - 1) {
        // לא בסוף הפרק
        // ב-block, בודקים אם הקטע הנוכחי מסומן כנקרא
        if (!currentChapter.chunks[book.currentChunkIndex].read) {
          alert("עליך לסמן את הקטע הנוכחי כנקרא לפני המעבר.");
          return;
        }
        book.currentChunkIndex++;
      } else {
        // סיימנו פרק, נעבור לפרק הבא
        // ב-block, בודקים אם כל הפרק נקרא
        if (!currentChapter.chunks.every(ch => ch.read)) {
          alert("סמן את כל הקטעים בפרק כנקראים כדי להמשיך לפרק הבא.");
          return;
        }

        const nextChapterIndex = book.currentChapterIndex + 1;
        if (nextChapterIndex >= book.chapters.length) {
          // אולי נטען פרק חדש
          const success = await loadNextChapter(book);
          if (!success) {
            alert("הגעת לסוף הספר או לא ניתן לטעון פרק נוסף.");
            return;
          }
          // נטען עכשיו ב-chapters[last]
          book.currentChapterIndex = book.chapters.length - 1;
          book.currentChunkIndex = 0;
        } else {
          // פשוט עוברים לפרק הבא
          book.currentChapterIndex = nextChapterIndex;
          book.currentChunkIndex = 0;
        }
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // פונקיית מעבר לקטע הקודם (במצב block)
    function goToPrevDay(bookId) {
      const book = books.find(b => b.id === bookId);
      if (!book) return;

      if (book.mode !== "block") return; // לא רלוונטי במצב accumulate

      if (book.currentChunkIndex > 0) {
        book.currentChunkIndex--;
      } else if (book.currentChapterIndex > 0) {
        book.currentChapterIndex--;
        book.currentChunkIndex = book.chapters[book.currentChapterIndex].chunks.length - 1;
      } else {
        alert("אתה כבר בקטע הראשון.");
        return;
      }

      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // פונקציה להסרת לימוד
    function removeBook(bookId) {
      if (!confirm("האם אתה בטוח שברצונך להסיר את הלימוד הזה?")) return;
      books = books.filter(b => b.id !== bookId);
      localStorage.setItem("books", JSON.stringify(books));
      debouncedRenderBooks();
    }

    // פונקציה להכנת המידע היומי בכל טעינה
    async function initDailyDataAndRender() {
      await dailyCheck();
      renderBooks();
    }

    // בעת טעינת הדף
    window.onload = function() {
      initDailyDataAndRender();
      setupKeyboardShortcuts();
      setupMobileSwipeSupport();
    };

    // קיצורי מקלדת
    function setupKeyboardShortcuts() {
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        
        // דוגמה: Ctrl + חץ שמאלה/ימינה במצב block
        switch(e.key) {
          case 'ArrowRight':
            if (e.ctrlKey) {
              // next day
              const bookId = getCurrentBlockBookId();
              if (bookId) goToNextDay(bookId);
            }
            break;
          case 'ArrowLeft':
            if (e.ctrlKey) {
              // prev day
              const bookId = getCurrentBlockBookId();
              if (bookId) goToPrevDay(bookId);
            }
            break;
        }
      });
    }

    // פונקציה שמחזירה ID של ספר במצב block ראשון שמוצאת (להדגמה)
    function getCurrentBlockBookId() {
      const blockBook = books.find(b => b.mode === "block");
      return blockBook ? blockBook.id : null;
    }

    // תמיכה בסווייפ מובייל
    function setupMobileSwipeSupport() {
      let touchstartX = 0;
      let touchendX = 0;
      
      document.addEventListener('touchstart', e => {
        touchstartX = e.changedTouches[0].screenX;
      });
      
      document.addEventListener('touchend', e => {
        touchendX = e.changedTouches[0].screenX;
        handleSwipe();
      });
      
      function handleSwipe() {
        const diff = touchendX - touchstartX;
        if (Math.abs(diff) < 50) return;
        
        const bookId = getCurrentBlockBookId();
        if (!bookId) return;
        
        if (diff > 0) {
          // swipe right => prev
          goToPrevDay(bookId);
        } else {
          // swipe left => next
          goToNextDay(bookId);
        }
      }
    }
  </script>
</body>
</html>
